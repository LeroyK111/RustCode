# 信号处理

信号是由操作系统或另一个进程发送给进程的软件中断，以通知它发生了事件。例如，当你的程序在终端上运行时，尝试按" control + c "，它会终止进程。这是你能看到的最常见的信号和信号处理之一。接下来我们将探索如何在Rust中处理这个信号和其他信号。

信号可以由不同的方式触发，如硬件、操作系统、用户输入或其他进程。当一个进程接收到一个信号时，这意味着一个事件已经发生，该进程可以根据信号的类型采取特定的操作。例如，进程可能需要停止运行、重新启动或处理错误。

在本文中，我们将了解信号的用途以及如何在Rust编程语言中处理信号，让我们开始吧。


## 信号的基础知识

信号被认为是事件的通知，就像我们在日常生活中对通知的反应一样，当你接到一个事件的通知时，你要么承担责任，解决它，要么选择忽略它。类似地，操作系统信号使进程能够对触发的事件采取行动或什么也不做。

例如，信号可以暂停或暂停正在运行的进程，将错误(如浮点异常)通知用户，或提供系统警报唤醒呼叫等信息。当接收到这样的信号时，应用程序可能需要关闭打开的句柄以释放系统资源或终止事件可能影响的任何活动。这就是当用户按下 "control + c" 时应用程序退出的情况。

信号类型
信号有几种类型，有些可以处理，有些则不能。下表显示了基于POSIX标准的一些信号类型及其可用代码。这个标准是一组为类Unix操作系统(包括Linux、macOS和各种Unix)定义api的标准。

如下：
SIGHUP(code: 1) - 当进程的控制终端关闭或断开连接时，该信号被发送到进程。

SIGINT(code: 2)- 当用户按下" control + c "中断进程执行时，该信号被发送给进程。

SIGQUIT(code: 3) - 此信号类似于SIGINT，但用于启动进程的核心转储，这对调试很有用。

SIGILL(code: 4) - 当进程试图执行非法指令时，这个信号被发送给进程。

SIGABRT(code 6)- 当进程调用abort()函数时，该信号被发送给进程。

SIGFPE(code: 8) - 当进程试图执行不允许的算术运算(如除零)时，该信号被发送给进程。

SIGKILL(code: 9) - 此信号用于立即终止进程，不能被捕获或忽略。

SIGSEGV(code: 11)- 当进程试图访问没有分配给它的内存时，这个信号被发送给进程。

SIGTERM(code: 15)- 这个信号被发送到一个进程，请求它优雅地终止。

SIGUSR1(code: 10) - 进程可以将这些信号用于自定义目的。

SIGUSR2(code: 12)- 与SIGUSR1相同。

## 信号处理
信号处理是指当进程接收到特定信号时，操作系统所采取的默认操作。三种可能的信号处理是：
Terminate：进程立即终止，没有任何清理或保存状态的机会。

Ignore：进程对信号不做任何响应。

Catch：进程运行用户定义的信号处理函数来处理信号。
这意味着不是所有的信号都能被处理，应用程序只能处理操作系统允许它处理的信号。但是，还有一些其他信号，如SIGKILL、SIGSTOP和SIGCONT，不能处理。例如，SIGKILL用于强制终止进程，不能捕获、阻塞或忽略它。

## 信号屏蔽
信号屏蔽是暂时阻止向进程或线程传递某些信号的过程。当被屏蔽时，一个信号被添加到一组阻塞的信号中，并且在解除阻塞之前不会被传递给进程或线程。

信号屏蔽通常用于防止在执行代码的关键部分时不能被信号处理程序中断。例如，在多线程程序中，代码的关键部分可能需要在不被信号处理程序中断的情况下原子地执行。在这种情况下，程序员可以暂时屏蔽可能中断临界区的信号，然后在临界区完成后将它们解除屏蔽。


## Rust中的信号处理

现在我们已经介绍了信号的基础知识，让我们深入研究在Rust中如何处理信号！与C语言中内置信号处理的语言模块不同，Rust提供了几个库，使开发人员能够轻松地处理信号。signal_hook、nix、libc和tokio等库主要使用C绑定来处理信号。

Tokio的信号处理
让我们看一个例子来展示如何在Rust中使用tokio处理信号。Tokio是处理信号的完美选择，因为它是异步的和安全的。顺便说一下，它在幕后使用的是libc。

在Cargo.toml文件中加入Tokio依赖项：

```toml
[dependencies]
tokio = { version="1.25.0", features=["full"] }
```
