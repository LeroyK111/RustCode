# Rust常见的反模式

1，过度使用unsafe

描述：Rust的unsafe关键字允许开发人员绕过某些安全检查。虽然在某些情况下是必要的，但过度使用unsafe可能导致未定义的行为，并损害Rust的安全保证。

建议：尽量减少unsafe的使用，并确保仔细审核任何不安全的代码，并将其封装在安全的API中。始终记录不变量，必须保持不安全的代码必须是安全的。

2，不必要的clone

描述：调用.clone()可能会很昂贵，特别是对于大型数据结构。无差别地克隆数据可能会导致性能问题。

建议：选择借用而不是克隆。考虑使用参考资料或其他借用技巧。当需要所有权时，考虑使用Rc或Arc来共享所有权。

3，忽略Result

描述：Result类型在Rust中用于错误处理，忽略函数返回的Result可能导致意外的行为和错误。

建议：始终正确处理Result，使用模式匹配，?操作符，或者在绝对确定结果为Ok时使用unwrap()。

4，循环引用的内存泄露

描述：像Rc和Arc这样的引用计数类型可以创建引用循环，这可能导致内存泄漏。

建议：在使用Rc和Arc处理复杂的数据结构(图)时要谨慎，考虑使用弱引用来打破潜在的循环。

5，滥用锁

描述：不正确地使用锁，如Mutex和RwLock，可能会导致死锁或性能瓶颈。

建议：尽量缩短锁的作用域，选择细粒度锁。考虑在线程之间使用通道或其他并发原语进行通信。

6，无限递归

描述：没有适当终止条件的递归函数可能导致栈溢出。

建议：确保递归函数有一个基本结束条件，如果递归深度无界，请考虑使用迭代方法。

7，无效地使用Collections

描述：使用不恰当的数据结构或算法会导致低效的代码。例如，与使用String builder相比，使用+=重复添加字符串可能效率较低。

建议：为任务选择正确的数据结构，并使用高效的算法。对于字符串连接，请考虑使用format!或者String builder。

8，过度使用动态分发

描述：通过trait对象(Box<'dyn trait >)进行动态分发会导致运行时成本。

建议：尽可能使用泛型静态分发，在处理真正的异构集合时，要谨慎地使用动态分发。

9，Panic不是错误处理

描述：使用panic!处理错误，可能导致代码的可维护性降低。

建议：使用Result类型进行错误处理并保留panic!对于不可恢复的错误。

10，忽略Drop语义

描述：不考虑Drop实现的顺序和行为可能会导致意外的行为，特别是当涉及到文件句柄或锁等资源时。

建议：注意对象被删除的顺序，并理解Drop实现的含义。确保正确执行任何所需的清理。

11，使用全局变量和静态变量

描述：使用全局可变状态会使代码更难推理，并可能引入线程安全问题。

建议：最好通过函数参数显式传递状态。如果必须使用全局状态，请确保它是线程安全的，例如使用Atomic类型或将其包装在互斥对象中。

12，低效的错误处理-expect

描述：在Result上使用expect方法的效率可能低于模式匹配，特别是在紧密循环中，因为即使不需要，它也会构造一个错误消息。

建议：使用模式匹配或?操作符在性能关键代码中用于错误处理。对于提供有利于调试自定义错误消息的情况，请保留expect。

13，没有有效地使用迭代器

描述：放弃使用迭代器方法而使用手动循环会降低代码的可读性，并可能降低效率。

建议：使用map、filter、collect等迭代器方法来编写更简洁、更地道的Rust代码。对大型数据集使用迭代器的延迟求值。

14，滥用Option和unwrap

描述：在一个选项上频繁使用unwrap会导致恐慌，是不正常的。

建议：最好使用if let或match来处理Option值。只有在绝对确定Option是Some时才使用unwrap。
