# Rust常见的反模式

1，过度使用unsafe

描述：Rust的unsafe关键字允许开发人员绕过某些安全检查。虽然在某些情况下是必要的，但过度使用unsafe可能导致未定义的行为，并损害Rust的安全保证。

建议：尽量减少unsafe的使用，并确保仔细审核任何不安全的代码，并将其封装在安全的API中。始终记录不变量，必须保持不安全的代码必须是安全的。

2，不必要的clone

描述：调用.clone()可能会很昂贵，特别是对于大型数据结构。无差别地克隆数据可能会导致性能问题。

建议：选择借用而不是克隆。考虑使用参考资料或其他借用技巧。当需要所有权时，考虑使用Rc或Arc来共享所有权。

3，忽略Result

描述：Result类型在Rust中用于错误处理，忽略函数返回的Result可能导致意外的行为和错误。

建议：始终正确处理Result，使用模式匹配，?操作符，或者在绝对确定结果为Ok时使用unwrap()。

4，循环引用的内存泄露

描述：像Rc和Arc这样的引用计数类型可以创建引用循环，这可能导致内存泄漏。

建议：在使用Rc和Arc处理复杂的数据结构(图)时要谨慎，考虑使用弱引用来打破潜在的循环。

5，滥用锁

描述：不正确地使用锁，如Mutex和RwLock，可能会导致死锁或性能瓶颈。

建议：尽量缩短锁的作用域，选择细粒度锁。考虑在线程之间使用通道或其他并发原语进行通信。

6，无限递归

描述：没有适当终止条件的递归函数可能导致栈溢出。

建议：确保递归函数有一个基本结束条件，如果递归深度无界，请考虑使用迭代方法。

7，无效地使用Collections

描述：使用不恰当的数据结构或算法会导致低效的代码。例如，与使用String builder相比，使用+=重复添加字符串可能效率较低。

建议：为任务选择正确的数据结构，并使用高效的算法。对于字符串连接，请考虑使用format!或者String builder。

8，过度使用动态分发

描述：通过trait对象(Box<'dyn trait >)进行动态分发会导致运行时成本。

建议：尽可能使用泛型静态分发，在处理真正的异构集合时，要谨慎地使用动态分发。

9，Panic不是错误处理

描述：使用panic!处理错误，可能导致代码的可维护性降低。

建议：使用Result类型进行错误处理并保留panic!对于不可恢复的错误。

10，忽略Drop语义

描述：不考虑Drop实现的顺序和行为可能会导致意外的行为，特别是当涉及到文件句柄或锁等资源时。

建议：注意对象被删除的顺序，并理解Drop实现的含义。确保正确执行任何所需的清理。

11，使用全局变量和静态变量

描述：使用全局可变状态会使代码更难推理，并可能引入线程安全问题。

建议：最好通过函数参数显式传递状态。如果必须使用全局状态，请确保它是线程安全的，例如使用Atomic类型或将其包装在互斥对象中。

12，低效的错误处理-expect

描述：在Result上使用expect方法的效率可能低于模式匹配，特别是在紧密循环中，因为即使不需要，它也会构造一个错误消息。

建议：使用模式匹配或?操作符在性能关键代码中用于错误处理。对于提供有利于调试自定义错误消息的情况，请保留expect。

13，没有有效地使用迭代器

描述：放弃使用迭代器方法而使用手动循环会降低代码的可读性，并可能降低效率。

建议：使用map、filter、collect等迭代器方法来编写更简洁、更地道的Rust代码。对大型数据集使用迭代器的延迟求值。

14，滥用Option和unwrap

描述：在一个选项上频繁使用unwrap会导致恐慌，是不正常的。

建议：最好使用if let或match来处理Option值。只有在绝对确定Option是Some时才使用unwrap。


15，不恰当的错误类型

描述：使用一般的错误类型，如Box<dyn std::error:: error >或字符串类型的错误，会使调用者很难以编程方式处理特定的错误。

建议：定义实现std::error:: error特性的自定义错误类型。在适当的地方使用枚举来表示不同类型的错误。


16，过度使用宏

描述：虽然宏可以减少样板文件并提供强大的元编程特性，但过度使用会使代码更难阅读、理解和调试。

建议：谨慎使用宏，对于常见的功能，更倾向于使用函数和特征，而对于能够提供明显好处的情况，则保留宏。


17，不使用const fn

描述：不使用在编译时执行的函数的const fn，可能会错过性能优化。

建议：将不依赖于运行时求值的函数标记为const fn，以便在编译时对其求值。


18，滥用派生

描述：在没有仔细考虑的情况下自动地在类型上派生诸如Debug、Clone、PartialEq等特征可能会导致意外的行为或性能问题。

建议：注意你所使用的特征，并确保它们适合你的类型。有时，手动实现一个特征更为合适。


19，没有利用cargo特性和工作空间

描述：忽略cargo特性会导致单块构建、更慢的编译时间和更大的二进制文件。

建议：利用cargo特性有条件地编译代码和依赖项，使用工作区来管理多包项目。


20，糟糕的文档和测试

描述：不提供文档和测试会使代码库的可维护性降低，也会使其他人更难做出贡献。

建议：用文档注释为公共api编写文档，并提供示例。编写单元测试和集成测试来确保代码的正确性。利用cargo doc生成文档，利用cargo test运行测试。


21，忽略生命周期

描述：没有正确指定生命周期可能会导致借用和所有权问题，特别是在更复杂的数据结构和函数中。

建议：必要时理解并使用显式生命周期，注意生命周期是如何与Rust中的引用和借用规则交互的。


22，没有使用AsRef和Borrow

描述：由于不使用AsRef和Borrow特性，函数在接受的参数类型方面会变得不那么灵活。

建议：在适用的情况下，让你的函数在AsRef或Borrow上通用，以接受对相同数据的多种类型的引用，增加你的API的灵活性和人体工程学。


23，生成过多的线程

描述：创建太多线程会导致上下文切换开销和资源耗尽。

建议：使用线程池实现基于任务的并行性，并注意生成的线程数量。考虑为io绑定任务时，使用带有异步运行时的异步编程。


24，不使用构建器模式进行复杂对象构造

描述：在单个表达式中创建复杂对象可能容易出错，并使代码更难阅读。

建议：使用Builder模式逐步构建复杂对象，使代码更具可读性，并允许对配置进行验证。


25，避免重新实现标准库类型

描述：重新实现标准库中可用的数据结构和算法通常是不必要的，并且可能引入错误。

建议：熟悉标准库，并在适当的时候使用它的类型和函数。如果有令人信服的理由，只实现自己的版本。


26，低效的序列化/反序列化

描述：不注意序列化和反序列化性能可能会导致瓶颈，特别是在联网或数据量大的应用程序中。

建议：选择高效的序列化格式和库。考虑使用Protocol Buffers或MessagePack之类的格式，并注意在可读性和性能之间进行权衡。


27，不使用自定义内存分配器

描述：默认全局分配器对于你的特定用例可能不是最有效的，特别是在性能关键型应用程序中。

建议：考虑使用jemalloc或mimalloc等自定义内存分配器来满足特殊的性能需求。

请记住，坚持最佳实践和避免反模式对于编写健壮、可维护和高效的Rust代码至关重要。不断学习和更新语言及其生态系统，以做出最佳的设计决策。