# Rust 正在重写可观测性基础设施

可观测性这个领域，正在悄悄发生一场大变革。Java 和 Go 统治基础设施这么多年，现在一批 Rust 写的新工具开始冒头——看看这些数据基础设施创业公司的选择：从最早国内开始的先行者 TiDB[1] 到最近几年的 SurrealDB[2]、LanceDB[3]、Databend[4]、Neon[5]……

这些项目不只是"跑得更快的替代品"。它们背后是一套不同的理念：可观测性系统该怎么建、怎么部署、怎么扩展。


不绕弯子：现代可观测性太贵了。不光是软件许可证，运行这套东西本身就烧钱。一个典型的生产环境要配齐：

一堆 Agent 进程跑在所有机器上，吃掉好几个 GB 内存
一整套 Kafka 集群专门缓冲遥测数据
指标、日志、链路追踪各一套存储系统
大把带宽用来传输这些数据
还有一条永远调不完的 Data Pipeline
随便问哪个 SRE 团队都知道，可观测性基础设施的开销经常能追上甚至超过业务系统本身。数据量还在指数级增长，这么下去肯定撑不住。


## 使用rust

Rust 不是又一门新语言那么简单。系统工程师受够了凌晨三点爬起来查内存 Bug，于是有了它：

不靠 GC 也能内存安全：Rust 让你不用在性能和安全之间做取舍。C/C++ 要你自己伺候内存，Java 和 Go 把问题藏在垃圾回收器后面——然后在最要命的时候给你来一发 Stop-the-World。Rust 两头都要：又快又安全，没有 GC 停顿，行为可预测。业界已经有不少验证：Google 说 Rust 团队的产出明显高于 C++ 团队[9]；Android 的内存安全漏洞占比从 2019 年的 76% 降到了 2024 年的 24%[10]。微软在用 Rust 重写 Windows 核心库[11]，Azure CTO Mark Russinovich 直接喊话：新项目别用 C/C++ 了，用 Rust。AWS 这边[12]，Firecracker（Lambda 和 Fargate 的底座）、S3、EC2、CloudFront，核心组件都跑在 Rust 上。

性能可预测：搞可观测性，稳定压倒一切。你肯定不想系统出故障的时候，采集器或者时序数据库正好在 GC。Rust 没有 GC，Agent 在高压下的表现和风平浪静时一样。个人觉的这是 Data Infra 非常关键的一个指标。

省资源：Rust 更省内存，实测只需要 Java 甚至 Go 的一小部分。小规模无所谓，到了上千台机器就是质变。把 100 MB 的 Java Agent 换成 10 MB 的 Rust Agent，一千台机器能省出 90 GB 内存跑业务。

并发不慌：可观测性工具要同时处理几千路数据流，并发 Bug 是隐形杀手。Rust 的所有权模型从根上卡死了数据竞争，写并行代码踏实多了，不用整天担心哪个角落会炸。当然，也不能神话，该死锁还是会出现死锁。

供应链更安全：少一类 Bug 就少一个攻击面。现在供应链攻击这么猖獗，可观测性代码能从语言层面杜绝 double-free 和缓冲区溢出，这点很重要。


## 开源技术栈
好几个开源项目正在用 Rust 重新定义可观测性基础设施：

Vector[13]（已被 Datadog 收购[14]）基本成了高性能数据采集的标杆。单实例每秒能处理几百万事件，资源占用还特别低，不用再搞一套 Kafka 集群做缓冲了。而且它把日志、指标、链路追踪统一处理，不用再跑一堆不同的 Agent。就我所知，国内已经不少先进的团队在用了。

OTel-Arrow[15] 是 OpenTelemetry 协议的升级版。借助 Apache Arrow 的列式格式，网络带宽能省 30%-70%[16]，序列化的 CPU 开销也降了。每天要传 TB 级遥测数据的公司（尤其 IoT 公司），光网络费就能省一大笔。原来 Go 写的，我们贡献了 Rust 的传输协议层。

GreptimeDB[17] 解决的是存储割裂问题（笔者的创业项目）。以前搞可观测性得同时跑 Prometheus、Elasticsearch、Tempo，运维累不说，跨信号关联也麻烦。统一存储把架构大幅简化，列式存储加专用压缩，成本能降一个数量级。

Perses[18] 是 CNCF 旗下的云原生可视化项目，主要用 Go 写的。定位是轻量级 Grafana 替代品，主打 GitOps 式的仪表盘管理。（嗯，我知道它不是 Rust 的，但是我们团队都非常喜欢它的理念，作为现代可观测性 Dashboard 是绝对值得推荐的）


## 架构

单个工具有意思，更有意思的是它们怎么拼成一套完整架构：

采集层（Vector）：统一 Agent，处理所有遥测类型，能做复杂的转换和路由
传输层（OTel-Arrow）：高效的标准化协议，省带宽省 CPU
存储层（GreptimeDB）：列式时序存储，统一存放，对象存储兜底
展示层（Perses）：云原生仪表盘，GitOps 友好


![](../../learning/src/objInfo/assets/Pasted%20image%2020251204223444.png)
- Rust 打底保证性能（Go 补位）
    
- Arrow/Parquet 作为通用数据格式
    
- 对象存储做主力持久化，便宜还能长期存
    
- 列式存储压得小、查得快
    
- **开放标准**优先，不搞私有格式


## 门槛

不只是"更快更省"那么简单：

1. **门槛降低**：基础设施便宜了、简单了，DevOps 团队不用随着数据量线性扩人。更实在的是，凌晨两点被叫起来救火的次数会少很多——不用再去重启挂掉的 Agent、调 Kafka、查可观测性系统自己的内存泄漏。
    
2. **架构简化**：组件少了，运维就轻松。可观测性系统简单到业务团队能自己搞定的时候，组织瓶颈就没了。
    
3. **历史数据不再奢侈**：Arrow/Parquet 的列式存储既能实时聚合，也能长期保存。存储成本降一个数量级之后，可观测性数据能存几周、几个月甚至几年，历史趋势分析和容量规划都能做了。
    
4. **边缘场景**：计算往边缘走，资源限制越来越紧。轻量级 Rust Agent 能跑在各种受限设备上，这点很关键。
    
5. **环保**：听起来虚，但是全球的数据中心吃掉全球至少 1% 的电， AI 的蓬勃发展将消耗更多的能源。可观测性系统省 90% 资源，规模一上来，减排效果相当可观。


- 数据库（SurrealDB[19]、Neon[20]）
    
- 服务网格（Linkerd2-proxy）
    
- 容器运行时（Youki）
    
- 构建系统（Turbopack）

