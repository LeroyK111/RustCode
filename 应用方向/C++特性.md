# Rust窃取了C++语言最好的特性

## 1，资源管理模型

讽刺的是，Rust从C++语言中偷来的第一个特性是资源管理模型。创造者提出了一个非常有用的设计模式，叫做RAII，它代表资源获取即初始化。其思想是，像堆分配内存、数据库连接和文件句柄这样的资源应该与对象的生命周期相关联。

当一个对象被创建时，它应该获得它需要的资源，这是在对象的构造函数中完成的。当对象被销毁时，应该释放资源，这是在对象的析构函数中完成的。这种设计模式带来了可靠的资源管理和更简洁的代码，最重要的是，它减少了资源泄漏的风险，这就是为什么它在整个C++标准库中被使用的原因。

事实上，ofstream已经在内部实现了RAII，所以我们可以直接使用它来操作文件，来自动清理堆分配的内存。我们可以使用标准库中的unique智能指针，并且可以使用第三方库来自动管理数据库连接。

RAII非常有用，以至于Rust采用了这种设计模式，并使其成为语言的核心部分。Rust标准库广泛使用了RAII，我们可以操作文件，并且句柄会自动释放。Box智能指针用于自动清理Heap分配的内存，我们可以使用第三方库管理数据库连接。

但是Rust并不止于此，它在C++传统的RAII模式之上提供了两个主要的改进。

首先，不像C++语言，Rust会防止你不小心搬起石头砸自己的脚，在C++语言中，你可以绕过RAII模式，使用new和delete操作符手动分配内存。这可能会导致错误，如在调用delete之后试图访问指针时出现use after free errors，如果意外调用delete两次则会出现double free errors，如果忘记调用delete则会导致资源泄漏。

这些bug会损害软件的稳定性、安全性和性能。微软曾有一份著名的报告，称其产品中70%的漏洞是由内存安全漏洞引起的。Rust避免了这些漏洞，因为它没有像new和delete这样的操作符，它只允许你使用RAII结构分配资源。

Rust在传统RAII模式之上提供的第二个主要改进是自动管理对数据的引用——当一个值被释放时，编译器强制检查引用的有效性。

编译器将通过执行编译时检查来防止对该已释放值的任何引用再次被使用，这意味着引用被保证指向有效的内存，所以你不必担心臭名昭著的bug，比如use after free errors和数据库错误之后继续使用指针。

Rust中的RAII模式称为所有权模型，与确保引用有效性的编译时检查一起称为借用模型。它们确保资源被自动清理，引用总是有效的，从而消除了一整类内存安全漏洞。


## 2，零成本抽象

Rust从C++语言学来的第二个特性是零成本抽象原则，这意味着，与使用循环和计数器等底层抽象的代码相比，泛型和集合等高级抽象不应该造成任何运行时开销或性能损失。这带来了很棒的开发体验，同时保持了闪电般的性能。

来看以下C++示例的代码：
![](../learning/src/objInfo/assets/Pasted%20image%2020240921002645.png)我们创建一个整数向量，然后使用for循环查找vector中的最大值。这段代码包括循环初始化、条件检查和元素比较，使其可读性较差，并且更容易出错。
![](../learning/src/objInfo/assets/Pasted%20image%2020240921002652.png)
这段代码现在变得简单多了，我们只需要调用标准库中的max函数即可。迭代器抽象封装了迭代和比较逻辑，使代码更简洁，更不容易出错，同时又不牺牲性能。

下面是我们如何在Rust中编写相同的代码：
![](../learning/src/objInfo/assets/Pasted%20image%2020240921002702.png)

首先，我们通过调用iter方法将vector转换为迭代器，然后通过调用max方法找到最大元素。在这个例子中，我们实际上使用了一些零成本抽象，第一个是迭代器抽象；第二个是Option枚举；第三个是模式匹配。

Rust的美妙之处在于，它建立在零成本抽象原则之上，进一步强调内存安全和线程安全。如果我们回到C++语言的例子，用一个空的Vector来调用max函数，这将导致未定义的行为。因为我们会返回一个不能安全引用的对象，但是在下一行中我们试图引用它。

另一方面，在Rust示例的代码中，Max方法返回一个Option类型。因此，如果我们在一个空Vector上调用它，它只会返回一个None，Option类型迫使我们检查返回类型是和Some还是None，这使得我们的代码更加健壮，同时保持了惊人的快速性能。

## 3，泛型编程

Rust从C++语言学来的第三个特性是泛型编程，在C++语言中，泛型编程是通过模板实现的。例子如下：
![](../learning/src/objInfo/assets/Pasted%20image%2020240921002720.png)模板允许你编写适用于任何数据类型的代码，提供灵活性和可重用性。这个模板函数称为print，它接受泛型T的单个参数，也受到Printable的约束。在这种情况下，对于被认为是Printable的类型，它必须能够输出到标准输出，并且操作必须返回对ostream的引用，通过使用这个概念作为对泛型类型T的约束，print函数确保它只会打印Printable类型的实例。

在Rust中受C++模板的启发，采用了泛型的思想，并对其进行了现代化改造。在rust中有两个关键的改进：

- 首先，简洁的语法使Rust泛型更直观，更易于阅读。
    
- 其次，Rust将泛型与它的Trait系统紧密地集成在一起。
    

示例代码如下：
![](../learning/src/objInfo/assets/Pasted%20image%2020240921002729.png)
在这个例子中，我们明确地声明泛型T必须实现Display Trait，这与C++中的概念类似，但它从一开始就是Rust的一部分。因为在Rust中，泛型和Trait是紧密集成的，所以当你使用不符合要求的类型时，你会得到明确的错误信息。

Rust的泛型方法还维护了我们前面讨论过的零成本抽象原则——编译后的代码就像为每个具体类型编写单独的函数一样高效，这实际上是Rust在编译时自动为你做的事情。

而且rust的所有权系统也适用于泛型代码，通过改进C++的模板系统，确保即使是泛型函数也是内存安全和线程安全的。Rust使泛型编程更易于访问和更安全，同时保持其强大的功能和性能优势。