# 问题描述

在项目转化过程中我遇到了一个与 CAS (Compare and Swap) [2] 操作实现相关的问题，在计算机科学中CAS 是多线程/协程中用于实现同步的原子指令。该软件针对不同的芯片平台，通过在C语言中根据芯片平台的类别进行宏定义并嵌入相应的汇编代码来实现CAS操作。我知道不同芯片平台对应的 CAS 操作的汇编代码是不一样的 [3]，例如：

x86-64 (Intel/AMD) 需要类似如下汇编代码块：

    lock cmpxchgq [destination], rdx
ARM 需要类似如下汇编代码块：

    ldrex r1, [destination]
    cmp r1, r2
    strexeq r1, r2, [destination]
PowerPC 需要类似如下汇编代码块：

    lwarx r0, 0, destination
    cmpw r0, r1
    bne retry ; branch if not equal
    stwcx. r2, 0, destination
    bne retry ; branch if store failed
然而如下面的代码片段所示，即使该软件使用相同的Intel x86芯片平台，但是在不同的操作系统平台上其实现的汇编指令也有可能是不一样的。

C头文件中 cas_operation.h 的部分代码如下：
#if defined(__i386) || defined(__x86_64__) || defined(__sparcv9) || defined(__sparcv8plus)
typedef unsigned int slock_t;
#else
typedef unsigned char slock_t;
#endif
extern slock_t my_atomic_cas(volatile slock_t *lock, slock_t with, slock_t cmp);
#define TAS(a) (my_atomic_cas((a), 1, 0) != 0)
#endif
对应实现的x86汇编文件 cas_operation.s 的部分代码如下：
my_atomic_cas:
#if defined(__amd64)
 movl       %edx, %eax
 lock
 cmpxchgl   %esi, (%rdi)
#else
 movl    4(%esp), %edx
 movl    8(%esp), %ecx
 movl    12(%esp), %eax
 lock
 cmpxchgl %ecx, (%edx)
#endif
 Ret
众所周知虽然Rust也有宏定义的包 Macros，但是目前也与C语言的有不小的差别。因此，在做转化的过程中如何做到芯片平台和操作系统级别的代码兼容则是我遇到的最大挑战。

## 解决方案

想到两个解决方案：

使用asm! 宏去处理不同芯片平台的汇编代码
使用 Rust代码对特定的操作进行针对性的实现
第一种方案比较简单，只需要在代码中使用std::arch::asm 包，然后使用 asm! 宏（类似 println! 宏）去包裹不同平台的汇编代码即可，这也是最直接最容易想到的解决方案，而且无需考虑具体的汇编操作实现的指令和代码。但是这方法杂糅了很多的不同平台的汇编代码，同时需要Rust做很多额外的平台相关的逻辑控制，对这些控制逻辑部分代码的维护也是一个持久且复杂的工作。比如对新的平台指令 RSIC-V 的支持也要纳入其中。

第二种方案则需要考虑具体的操作逻辑，然后通过Rust代码去实现与汇编指令相同的逻辑，虽然有较大的工作量，但是这种方案可以消除由于芯片和系统平台不同带来的各种汇编代码实现的差异。 关于第一种方案的实现读者可以参照文档 Inline assembly [4] 中去做。针对 CAS 操作的第二种方案的实现则是本文主要提出的一种解决方案，而本文以类似Rust u32类型的 CAS 操作为例子实现其代码，在 my_compare_and_swap.rs 中会有如下代码段实现：

use std::sync::atomic::{AtomicU32, Ordering};

pub type uint32 = libc::c_uint;
pub struct my_atomic_uint32 {
 pub value: uint32,
}

impl my_atomic_uint32 {
    #[inline]
    pub fn compare_and_swap(&self, expected: uint32, newval: uint32) -> bool {
        let atomic_ptr = self as *const my_atomic_uint32 as *const AtomicU32;
        let atomic = unsafe { &*(atomic_ptr) };
        atomic.compare_and_swap(expected, newval, Ordering::SeqCst) == expected
    }
}

pub fn my_compare_and_swap_u32_impl(
    mut ptr: *mut pg_atomic_uint32,
    mut expected: *mut uint32,
    mut newval: uint32,
) -> bool {
 let atomic = &*ptr;
 atomic.compare_and_swap(*expected, newval)
}

下面我来解释一下上面的代码。由于是从 C 转到 Rust，因此我使用了 Rust 的 libc 包来自定义 uint32类型。然后通过自定义struct my_atomic_uint32 来对uint32进行CAS原子操作的包裹，同时对于此 struct实现其 inline 的compare_and_swap 操作函数。在该函数的实现中最关键的是将my_atomic_uint32的实体转化为一个AtomicU32的常量（注意需要在 Rust 代码文件开头使用 std::sync::atomic::{AtomicU32, Ordering} [5]），然后通过调用 AtomicU32 的compare_and_swap 来最终实现 uint32 的 CAS 操作。另外对于Ordering::SeqCst内存顺序 [6] 的选择也是比较考究的一个话题，这里我使用 SeqCst实际上是一个在保证正确的情况下不太考虑效率优化问题的选项。代码的最后my_compare_and_swap_u32_impl 则是对外使用的 u32 的 CAS 操作（事实上该软件主要也是需要实现 uint32 的 CAS 操作）。

## 结论

在本例中由于刚好有对应AtomicU32的CAS 实现，而且软件中整个原子同步的代码部分都是使用uint32进行的比较交换操作，因此我选择第二种方案则是最佳选择。由此可知上述的两种解决方案其实是各有利弊的，我必须结合实际的应用场景才能去做决定。那么这里有一个问题，如果需要对许多数据类型(比如uint32, int32, uint64, int64, float, float32, float64……)进行比较交换操作，又该做何种选择呢？这也许是仁者见仁智者见智的。

## 系统环境问题

本文将记录转化过程中遇到的另外一个问题。该问题是由已经转化完成的 Rust 代码使用到软件中引入的第三方软件包和链接库所导致的。设想这样一个场景：Rust 项目中完成某一个功能点需要用到一个或多个第三方软件包和链接库。这显然是很常见的用户场景，但是由于用户环境不同，用户安装的第三方软件包和链接库的版本不同，使得转化后的 Rust 代码必须要做适当的兼容处理。

这里所说的用户的环境不同，可以理解为芯片指令集的平台不同，如 Intel x86 以及国产的 ARM 麒麟服务器。当然更常见的情形是芯片平台相同，但是存在操作系统层面第三方软件包和链接库安装的差异，如 x86 下的 Ubuntu 和 CentOS 中用户安装了不同版本的第三方软件包和链接库等。

事实上，即使排除所有平台和系统层面的差异，由于用户安装了该基础软件所依赖的不同版本的第三方软件包和链接库，然而这些第三方软件包或者链接库由于自身的演进导致不同版本之间存在较大差异（可能实现相同功能的函数和函数签名都有千差万别），这给我重写该软件的工作带来了一些挑战。基于上述说明，在完成重写该基础软件的过程中如何使得转化后的 Rust 代码能兼容该基础软件所依赖的主流第三方软件包和链接库则是我遇到的最大挑战。需要说明的是这里的第三方软件包和链接库可能是基于 Rust 语言开发的，也可能是基于 C 语言开发的。

### 解决方案

对于此问题的解决方案需要使用 Rust FFI(Foreign Function Interface) [1]，这基本上是没有太大争议的。因为在本次软件重写过程中我遇到的场景是：对于不同版本的链接库使用哪个版本的函数取决于用户的安装运行时环境，所以除了 Rust FFI，在代码适配上我还考虑了使用 Rust features [2] 机制。

下面我简化了一下场景和解决方案，同时我把样本代码放到了我的 github [3] 里，欢迎大家一起交流。如样本代码所示，my-rust-bin 文件夹中的一段业务代码需要调用到静态链接库 my_rust_lib 中的函数，该链接库有两个版本 v1（在文件夹 my-rust-lib-v1 中） 和 v2（在文件夹 my-rust-lib-v2 中）， 且不同版本的库其函数不一样。

my-rust-lib-v1 对应的业务函数为：pub fn my_rust_lib_v1(left: usize, right: usize) -> usize
my-rust-lib-v2 对应的业务函数为：pub fn my_rust_lib_v2(left: usize, right: usize) -> usize
另外一个 lib 文件夹的目的其实是为了模拟用户本地安装的链接库。可以分别编译不同版本的静态链接库，然后把生成的库文件（在本例中是）libmy_rust_lib.a, 然后把不同版本的库文件拷贝到此文件夹下，以此来模拟用户环境中安装的不同版本的链接库。解决方案中的关键点在于 my-rust-bin 中，

首先在 my-rust-bin 的 Cargo.toml 中有定义对应的 features，如下所示：

```toml
[features]
v1 = []
v2 = []
```

其次在 my-rust-bin 的 src/main.rs 下的代码如下：

```rust
#[cfg(feature = "v1")]
mod bindingmylib {
    extern "C" {
        pub fn my_rust_lib_v1(left: usize, right: usize) -> usize;
    }
}

#[cfg(feature = "v2")]
mod bindingmylib {
    extern "C" {
        pub fn my_rust_lib_v2(left: usize, right: usize) -> usize;
    }
}

#[cfg(not(any(feature = "v1", feature = "v2")))]
compile_error!("Please specify either 'v1' or 'v2' feature");

pub fn my_rust_lib(left: usize, right: usize) -> usize {
    #[cfg(feature = "v1")]
    unsafe {
        return bindingmylib::my_rust_lib_v1(left, right);
    }

    #[cfg(feature = "v2")]
    unsafe {
        return bindingmylib::my_rust_lib_v2(left, right);
    }
}

fn main() {
    let r_value: usize = my_rust_lib(3, 5);
    println!("The return value of my_rust_lib is [{}]", r_value);
}
```
现在我来解读一下这段代码。代码先分别定义一个相同的模块 bindingmylib，然后根据 features 分别引入的依赖，使用的不同的静态链接库函数（my_rust_lib_v1 和 my_rust_lib_v2）, 同时通过 compile_error! 定义一个没有设置 v1 和 v2 features 的编译错误（防止编译时忘记设置 features选项，下面在编译环节的时候有用）。最后将两个有差异的函数统一为函数 my_rust_lib，并在该函数中根据 features 定义分别调用不同的函数并返回相应的值。

最后是在 my-rust-bin 中编译二进制文件：

```shell
# 编译 v1 版本的 my-rust-bin
$ cd my-rust-bin
$ cargo build --features="v1"

# 运行 v1 版本的 my-rust-bin
$ target/debug/my-rust-bin
my_rust_lib_v1: 8
The return value of my_rust_lib is [8]
```

编译并运行 v2 的二进制文件:
```sh
# 编译 v2 版本的 my-rust-bin
$ cd my-rust-bin
$ cargo build --features="v2"

# 运行 v2 版本的 my-rust-bin
$ target/debug/my-rust-bin
my_rust_lib_v2: 8
The return value of my_rust_lib is [8]
```

备注：如果编译的时候没有设置 --features 则会有如下输出：
```sh
$ cargo build
error: Please specify either 'v1' or 'v2' feature
  --> src/main.rs:16:1
   |
16 | compile_error!("Please specify either 'v1' or 'v2' feature");
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
```
至此，用户在编译好该基础软件之后，就可以无感知的通过统一的函数入口调用不同版本的相同链接库中的不同函数了。

### 总结
本文主要是在简化了问题的实际场景以后，解决不同版本的同一软件包或者链接库中，函数及其函数签名不同导致的调用问题。之所以说简化，主要是本文所描述的场景中，my-rust-bin 和其依赖的外部链接库均是 Rust 编写。而在我的实际场景中则会更复杂一些，存在着 Rust 代码依赖 C 编写的外部链接库，同时存在混合的原来 C 代码部分依赖新改写的 Rust 外部链接库的情况。但是无论哪种情况，万变不离其宗，我们都可以从这种最简单的场景出发去解决遇到的问题。