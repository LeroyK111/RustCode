# Discord 从 GO 迁移到 RUST

## Rust中的内存管理

Rust没有垃圾收集，所以Discord认为它不会有与Go相同的延迟峰值。

Rust使用了一种相对独特的内存管理方法，它包含了内存“所有权”的概念。基本上，Rust跟踪谁可以读写内存。它知道程序何时在使用内存，并在不再需要内存时立即释放内存。在编译时强制内存规则，使得运行时内存错误几乎不可能发生，不需要手动跟踪内存。编译器会处理它。

因此，在Rust版本的Read States服务中，当用户的Read State从LRU缓存中被驱逐时，它将立即从内存中释放。Rust知道它不再被使用，并立即释放它。没有运行时进程来确定是否应该释放它。


## 实现、负载测试和启动

实际的重写相当直接。它开始是一个粗略的语言转换，然后在有意义的地方进行了精简。例如，Rust有一个很好的类型系统，广泛支持泛型，所以可以抛弃那些仅仅因为缺乏泛型而存在的Go代码。此外，Rust的内存模型能够推断跨线程的内存安全，因此能够抛弃一些在Go中需要的手动跨线程内存保护。

当Discord开始负载测试时，他们立即对结果感到满意。Rust版本与Go版本一样好，并且没有延迟峰值！

值得注意的是，在编写Rust版本时，只对优化进行了非常基本的思考。即使只是进行了基本的优化，Rust也能够胜过手动调整的Go版本。这是一个巨大的证明，用Rust编写高效的程序是多么容易。

经过一些分析和性能优化，Discord能够在每一个性能指标上击败Go。延迟、CPU和内存在Rust版本中都更好。

## Rust性能优化包括：

1，在LRU缓存中使用BTreeMap而不是HashMap以优化内存使用。

2，将最初的度量库替换为使用Rust并发性的度量库。

3，减少内存拷贝的数量。

Discord进行了负载测试，所以发行过程相当无缝。把它放在一个金丝雀节点上，发现了一些缺失的边缘情况，并修复了它们。不久之后，Discord将其推广到整个开发团队。

## 提高缓存容量

服务成功运行了几天后，Discord决定是时候重新提高LRU缓存容量了。在Go版本中，提高LRU缓存的上限会导致更长的垃圾收集。现在不再需要处理垃圾收集，因此可以提高缓存的上限，从而获得更好的性能。Discord增加了内存容量，优化了数据结构以使用更少的内存，并将缓存容量增加到800万个Read States。