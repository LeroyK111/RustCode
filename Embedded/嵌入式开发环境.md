# 如何运行RUST

取决于应用的环境和需求，有多种方式可以运行基于Rust的固件。一般有两种方式使用Rust编写的固件：托管环境或是裸机，接下来让我们讨论这两种方式。

## 什么是托管环境？
在Rust中，托管环境近似于正常的PC，也就是说会为你提供一个操作系统。有了操作系统，你就可以构建Rust的标准库（std）了。std指标准软件库，可以看作是每次Rust安装都会包括的模块和类型。std提供构建Rust程序的多种功能，包括数据结构、网络、互斥量和其他同步原语、输入输出等。

在托管环境下，你可以在基于C语言的ESP-IDF开发环境中使用Rust。ESP-IDF中提供newlib环境，其上可以构建Rust的标准库。换言之，在托管环境方式（有时直接被称作std环境）中，我们可以将ESP-IDF作为一个操作系统，然后在其上构建Rust应用。这样我们可以利用上面的标准库功能，以及ESP-IDF API中用C语言已经实现的功能。

在清单1中你可以看到在ESP-IDF（FreeROTS）中的闪灯代码样例。esp-idf-hal中能找到更多的样例。

- 丰富的功能
如果你的嵌入式系统需要许多功能，例如网络协议、文件I/O或是复杂的数据结构，那么托管环境可能更合适。std库提供多种功能，帮助开发者快速、高效地构建复杂的应用。

- 可移植性
std箱子提供一组标准的API，可以跨平台和体系结构使用，帮助编写可移植和可重用的代码。

- 快速开发
std箱子提供了丰富的功能，不需要担心底层细节就可以快速、高效地构建应用。

## 嵌入式三种开发形式

想要搞清楚RTOS的“实时”，先要明白目前嵌入式领域三种开发形式——裸机开发（Bare Metal）、RTOS、GPOS（General-Purpose Operating System，通用操作系统），其主要特点如下：
![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20241207172809.png)
## 裸机：

裸机系统不使用操作系统。相反，应用程序代码直接在硬件上运行，无需操作系统支持，代码可以直接与硬件交互并访问硬件。裸机开发在资源受限的场景效果非常好，比如8位、16位MCU，或者只有32KB闪存、2KB RAM时。当然，资源很丰富时候也可以采用裸机开发，就比如系统拥有高度的实时要求。目前，EEWorld论坛便拥有许多青睐于在裸机上开发的工程师。

裸机意味着我们没有任何操作系统。当使用no_std编译Rust程序时，程序不能使用一些特性。这不意味着你不能使用网络或者复杂的数据结构，no_std下能够做到所有在std下的功能，只是no_std情况下更为复杂和具有挑战性。no_std程序依赖于一组所有Rust环境共享的核心语言功能，包括数据类型、控制结构或者底层内存管理。嵌入式开发中存储受限，需要对底层硬件进行控制，裸机环境会更加适合。

在清单2中你可以看到在裸机环境（无操作系统）中的闪灯代码样例。esp-hal中能找到更多的样例。

- 需要节约存储
如果你的嵌入式系统中资源受限，需要节约存储，那么你可能需要裸机环境。std的功能会导致会更长的编译时间和更大的二进制文件。


- 直接控制硬件
如果你的嵌入式系统需要更直接地控制硬件，像是使用底层设备驱动或是专有硬件功能，你可能需要裸机环境。std中的抽象化可能会让硬件交互变得困难。


- 实时和时间关键应用
如果你的嵌入式系统需要实时性能或者低延迟响应，那么裸机环境会更好。std会增加难以预测的延迟和开销，这会影响实时性能。


- 定制需求
裸机环境允许更多的定制和对应用行为的细粒度控制，这在特定和非标准环境中非常有用。

## RTOS

顾名思义，旨在为实时应用程序提供服务，这些应用程序提供可预测的执行时间和时间敏感型应用程序，其的关键特征在于响应性和确定性。相比裸机，RTOS更方便。要使用RTOS，系统应至少拥有 64 KB闪存、4 KB RAM和80 MHz或更高的处理器时钟。

RTOS通常用于比裸机更复杂时序要求的系统，通常需处理TCP/IP、MQTT、USB、Wi-Fi 等通信堆栈时管理实时需求。虽然裸机也能开发这种系统，但RTOS可以简化设计，加快上市时间，并使软件维护更容易。RTOS的另外关键点在于软件开发添加的功能，如务管理、任务同步、调度和任务间通信。RTOS允许考虑相互抢占的任务，从而允许更复杂的应用程序设计。
### **RTOS不能做什么**

从裸机到RTOS，实际上工程师会存在许多困惑，EEWorld论坛中，工程师jorya_txj就曾用自己过去的经历，诉说自己对于RTOS的理解：

他表示，目前接触了几位从裸机转向RTOS的人士，接触了一些项目，有一些感想，对于不了解RTOS的人，可能感觉这个东西很神秘，能解决任何裸奔解决不了的事情，可事情往往不是这样的。

裸奔只做一件事情是最有效率的，如果干一件事情裸奔都很吃力，rtos解决不了硬件负债的事情，相反使用rtos会更差。举例说明，假设系统有一个20us频率的中断在cortex-m3 上面，中断内最大耗时10us。那中断内留给rtos的只有10us了，这10us内还需要调用rtos的队列发送api。虽然有的系统能响应20us中断，但是保证不了10us内能完成api的调用以及出中断处理。即使能保证，外面任务的执行效率将会很差很差。

绝大部分的RTOS做不了1us以内的中断响应。也就是说中断发生了之后，需要1us就能处理用户的中断函数。

上面两个例子只能从硬件设计上去着手，从根本上去解决这个问题。比如第一个问题可以采用专用的芯片或者控制器去降低中断的频率。第二个问题可以采用FPGA去完成精确地定时等等。

RTOS更像一个军队管理决策者，而不是一个冲锋在前面的勇士。一个系统越趋向复杂RTOS的优势越大，一个系统越趋向简单，ROTS越无用武之地。RTOS很多时候不是救命稻草,硬件设计的问题还是需要硬件设计去解决，不能侥幸带到软件这边去解决，即使软件侥幸能解决这一次，下一次可能又解决不了了，不具备通用性。

### “实时”到底是什么

当有人问他，“实时”到底是啥时，他一股脑地回答道：“就是反应快呗，比如打开网页，最好是1ms都不要等......”但得来的回应是连实时是啥都不懂。实际上，实时性是指在规定的时间内响应，而不是说什么越快越好。

根据响应时间在微秒、毫秒和秒级的不同，系统的实时性响应分为三种，RTOS属于硬实时：

- 第一种是硬实时（Hard real-time），是对即时的事件作出反应，绝对不能错过事件处理时限，任何错过的最后期限视为系统故障。就是接近我们平素谈到的RTOS的及时响应，它不是强调反映有多快，而是要在规定的死限时间之前完成就可以了。
    
- 第二种是软实时（Soft real-time），是允许经常错过最后期限，只要任务及时执行，它们的结果就会继续有价值。接近WINDOWS、Linux桌面版这类常用系统，软实时是指统计意义上的实时，一般整体吞吐量大或整体响应速度快，但不能保证特定的任务在指定的时间内完成。
    
- 第三种是准实时（Firm real-time），即使系统未能满足最后期限，可能不止一次（即对于多个请求），系统也不会被视为失败。此外，一旦特定请求的截止日期已过，对请求的响应（对查询的答复、任务的结果等）将毫无价值（在截止日期之后结果的有用性为零）。
    

其他工程师则对实时也有自己理解。他们认为，实时就是系统对事件的响应时间能满足需求，这样就可以看作是实时，因为事件总是能够在限定的时间内得到响应处理。具体的说，每一个事件的响应时间，跟现实时间是确定关系。在正常工作环境中，不会出现不确定，这样的系统就叫做实时系统。

所以，可以说，所谓的实时，并非真的实时。知名嵌入式工程师StrongerHuang也同样写过：严格来说，RTOS也不是实时响应并处理紧急的事情，只是在很短时间（一般ms级别）就做出了响应，给人感觉就是实时在响应。

比如说，RTOS实时响应的重要配置系统滴答（SysTick），按理来说，系统滴答值（节拍）越大响应越快，但系统调度也需要占用时间，所以，滴答值也不是越大越好。再比如，用中断就能做到实时响应，但硬件中断只能做出一个“紧急通知”，不能做出（耗时的）执行动作。

另据其他工程师分享，RTOS的实时是指时间可控，能在某个需求时间窗口内执行完成。而不是指立刻执行，所以RTOS是实时操作系统。硬件中断退出后立即执行高优先级任务，所以优先级配置合理的话，能在us甚至ns级响应。其实写得好得裸机响应跟RTOS差不多，但RTOS最大的优势在于任务调度，当功能复杂时可以通过操作系统调度而不用担心任务冲突。

### RTOS的四种分类
实际上，RTOS本身也会按响应级别分为四种类型，它们用于不同类型的嵌入式系统：

1.硬实时操作系统（Hard RTOS）：硬实时操作系统广泛用于负责处理关键任务和要求精确时间限制的嵌入式解决方案。这意味着某些事件必须在预定的时刻执行，而不是早或晚一秒执行，因为这会导致严重问题甚至对系统造成物理损坏。案例包括汽车巡航控制和铁路信号系统。

2. 软实时操作系统（Soft RTOS）：软实时操作系统适用于嵌入式系统，其中缺少预定义的时间限制不会严重影响相关流程和整体系统运行。它允许设置执行特定任务的时间截止日期，但错过这些截止日期不会停止系统运行。例如机上娱乐和语音聊天应用程序。

3. 准实时操作系统（Firm RTOS）：准实时操作系统是硬RTOS和软RTOS的中间地带，其工作原理如下：使用准RTOS时，系统任务可能会错过最后期限，而不会对流程和系统运行产生影响。然而，可以错过的任务数量是有限的，如果它们超过允许的数量，将导致严重的系统错误和延迟。例子包括机器人装配线和电信网络。

4. 确定性实时操作系统（Deterministic RTOS）：确定性实时操作系统与时序必须始终精确的嵌入式系统完美匹配。这种类型的实时嵌入式编程允许预测执行不同优先级和复杂性的任务所需的时间。确定性调度将使我们能够设置准确执行关键任务的时间框架。它使嵌入式系统运行可预测、稳定可靠。

## GPOS：

主要包括Linux、Windows等，旨在运行各种软件应用程序。这些操作系统专为用户交互而设计，提供某种界面，无论是命令行界面 （CLI） 还是图形用户界面 （GUI），旨在运行多个应用程序（通常具有多线程），并提供其他优势，例如资源/文件管理和设备驱动程序。用户交互通常是 GPOS 设计的主要关注点，因此一些延迟是可以接受的。同时，硬件也通常是32位以上处理器，主频达到200MHz以上，闪存达到数兆。

因为Linux本身比较复杂，所以也诞生了介于RTOS和Linux之间的实时Linux（如Ubuntu的实时Linux）。实时Linux的核心概念是“抢占”，也就是中断当前执行线程，立即处理优先级较高的事件。RTOS和实时Linux之间的选择取决于系统特定延迟要求，以及对开销和资源效率的需求。虽然实时Linux为许多场景提供了强大的解决方案，但在某些关键的嵌入式系统中，专用 RTOS可能仍然更可取。如果项目需要在实时需求和运行各种应用程序的灵活性之间取得平衡，那么实时Linux将提供更通用的解决方案。


