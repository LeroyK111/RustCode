
鉴于目前现代嵌入式系统愈发强大的功能以及在其上集成混合安全关键系统的趋势，能够实现空间和时间隔离的虚拟化技术受到了广泛的关注。目前，成熟的虚拟机管理程序（如KVM和Xen）在设计时并未考虑嵌入式平台的需求和限制。针对嵌入式平台的静态分区虚拟机管理程序目前有Jailhouse 和Bao 两种方案。Jailhouse 似乎能够满足嵌入式平台的需要，但是它仍然依赖Linux来引导和管理虚拟机。本文介绍了Bao，它基于Arm-v8和RISC-V平台，从大小、性能和中断延迟等角度进行评估，该方案产生的虚拟化开销较小。

在汽车和工业控制等领域，近年来日益增长的功能需求对嵌入式系统的计算能力提出了较高要求，同时也引发了嵌入式系统的创新，从运行简单的裸机应用程序或实时操作系统的小型单核微控制器，转变为具有复杂的层次存储结构、并且能够使用功能丰富的通用操作系统（GPOS）的强大的多核平台。同时，降低尺寸、重量、功率和成本的市场需要也指导了嵌入式系统的发展方向——将多个子系统整合到同一个平台上，这通常意味着将关键级别不同的系统整合为混合关键系统（MCS）。因此，平台需要平衡不同的需求，包括安全子系统和非安全子系统的隔离，以及共享资源访问的效率。  

虚拟化是桌面和服务器中已经成熟的技术，是实现资源整合和集成的解决方案，能够保证虚拟机 (VM) 之间的隔离和故障控制。典型的面向服务器的虚拟机管理程序有Xen [19,47]和KVM[26,12]，为了让它们适应嵌入式架构（主要是Arm），学界已经做出了一些努力，并取得了相当大的成功。它们仍然不适用于混合关键系统的原因如下：其一，鉴于系统的混合关键性特质，逻辑隔离已被证明不足以满足严格的嵌入式约束和实时要求[1]。其二，这些嵌入式管理程序通常依赖于大型GPOS（通常是Linux）来引导、管理虚拟机或提供服务，例如设备仿真和虚拟网络[4,41]。从功能和信息安全的角度来看，这种依赖关系使系统的可信计算根（TCB）变得过于臃肿，并会影响安全启动机制中的信任链，总体上扩大了系统的攻击面[32]。其三，由于此类操作系统的规模和单体架构，这种紧密耦合会阻碍部署此类虚拟机管理程序的系统的安全认证过程。  

静态分区虚拟机管理程序架构最近在学术界和工业界的MCS中得到越来越多的采用，由西门子开发的Jailhouse[41]是这一架构的先驱者。该架构利用硬件辅助虚拟化技术，采用最小软件层，静态划分所有平台资源，并将每个资源专门分配给单个VM。它假定不需要在客户机之间共享硬件资源。由于每个虚拟内核都静态绑定在单个物理CPU 上，因此无需调度程序，也无需提供复杂的语义服务，进一步降低了尺寸和复杂性。尽管可能会妨碍高效资源使用的需求，静态分区允许在隔离和实时方面提供更强的保证。尽管如此，Jailhouse仍然依赖Linux来引导系统和管理它的“牢房”（“cell”），仍存在与其他虚拟机管理程序相同的上述安全问题。  

尽管静态分区方法提供了强大的CPU和内存隔离，这仍然不够，因为许多微架构资源（例如最后一级缓存、互连和内存控制器）仍然在分区之间共享。由此产生的争用导致缺乏时间隔离，损害性能和确定性[3,2]。此外，恶意虚拟机可以利用这一点，通过增加共享资源的消耗来实施拒绝服务式攻击[6]，或者通过隐式定时侧通道[13]间接访问其他虚拟机的数据。为了解决这个问题，诸如缓存分区（通过锁定或着色）或内存带宽预留之类的技术已经被提出并在操作系统和虚拟机管理程序级别实现[48,27,30,22]。  

本文中我们将介绍 Bao，一个从零编写的、实现分区架构的最小虚拟机管理程序。尽管遵循与Jailhouse相同的静态分区架构，Bao不依赖任何外部代码（除了执行低级平台管理的固件）。此外，鉴于机制的简单性，它提供了对缓存着色的支持。Bao最初针对的是Arm-v8架构，对RISC-V架构的实验性支持也已完成。Bao于2019年底开源。

## **Bao 虚拟机管理程序**

Bao（来自汉语普通话“保护”）是一个面向信息和功能安全的轻量级裸机虚拟机管理程序。它专为MCS设计，重点关注隔离、故障控制和实时行为。它只包括一个最小的特权软件，利用处理器指令集（ISA）虚拟化支持来实现静态分区虚拟机管理程序架构（图1）：资源在VM实例化时被静态分区和分配；内存是使用两阶段翻译静态分配的；I/O只能够直通；虚拟中断直接映射到物理中断；实现了虚拟CPU到物理CPU的1对1映射，无需调度程序；管理程序还提供了虚拟机间通信机制（基于静态共享内存和通过超级调用（hypecall）触发的虚拟机间中断的异步通知实现）。除了标准的平台管理固件，Bao没有外部依赖（例如，不需要高权限VM运行大型、不可信GPOS），因此TCB更小。
![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20250419124924.png)

**平台支持**

Bao目前支持Arm-v8架构。RISC-V因需要实验性的虚拟机管理程序扩展，仅能够在仿真器上实现。截至撰写本文时，Bao已移植到两个Arm-v8平台：ZCU102/4开发板上Xilinx的Zynq-US+和Hikey 960上的海思麒麟960。到目前为止，Bao能够在裸机上托管多种应用程序，FreeRTOS和Erikav3 RTOS，以及原版Linux和Android（编者注：截至撰稿期间已经有Arm-v8/v7，v8-R，RV32/64架构30余种开发板支持，并支持托管Zephyr RTOS）。  

除了简单的串行驱动程序来执行基本的控制台输出，Bao不依赖额外的设备驱动程序，并且只需要少量的平台相关描述（例如，CPU数量、可用内存及其位置）即可移植到新平台。出于这个原因，Bao依赖供应商提供的固件和通用引导加载程序来执行硬件初始化以及低级管理功能，并将管理程序和客户机镜像加载到主内存中。这显著减少了移植工作。

**空间和时间隔离**

按照隔离的要求，Bao首先为每个物理CPU设置私有映射。通过使用递归页表映射技术，Bao避免了对物理内存的完整连续映射。这种方法通常不适用于管理多个地址空间，并且时常会导致页表查找的翻译后备缓存（TLB）占用空间过大。但是，在Bao中每个CPU仅有一个地址空间，而且在初始化时页表会被完整地建立起来，这一结论就不一定适用了。此外，管理程序代码页被标记为只读，管理程序数据页被配置为不可执行。关于时间分割，鉴于独占的CPU分配，不需要调度程序，再加上CPU计时器由客户机直接管理，Bao允许逻辑上的完全时间隔离。  

尽管Bao拥有强大的分割特性，并且为最小化现有虚拟化开销做出了很多努力，但这还不足以保证执行的可确定性，并满足关键客户机任务的最后期限。共享最后一级缓存（LLC）的争用仍然允许客户机分区之间在微架构层次的干扰。因此，鉴于其简单性，Bao 从一开始就实现了页面着色机制，从而实现了LLC缓存分区。然而，着色有几个缺点：首先，它强制使用可用的最细粒度的页面大小，抵消了使用超级页面的好处。其次，因为它还划分了实际的物理地址空间，导致内存浪费和碎片。关于着色的另一个问题是，由于Bao依赖引导加载程序加载客户机镜像，这些镜像在内存中重新布局，它需要重新着色它们，将加载的原始镜像中不符合该VM颜色的页面复制到颜色相同的页面，这将增加VM的启动时间。Bao可以单独为每个VM启用着色，每个VM一种颜色。

**I/O和中断**

Bao在只能直通的I/O配置中直接将外围设备分配给客户机。在支持的架构中，特别是Arm，所有I/O都是内存映射的，这是通过使用现有的内存映射机制和虚拟化支持提供的2阶段转换实现的。管理程序不验证给定外围设备的排他分配，这允许多个客户机共享它，尽管是以非监督方式。通用中断控制器（GIC）是Arm架构中的中断路由器和仲裁器，尽管它提供了一些中断虚拟化设施，但大多数可用的硬件平台都只配有GICv2或GICv3，它们不支持将中断直接传递到客户机分区。所以，所有中断都会先转发到管理程序，管理程序必须使用一组有限的挂起寄存器在VM中重新注入中断。除了特权模式的开销导致不可避免的中断延迟增加之外，这还显著增加了中断管理代码的复杂性，尤其是要模拟中断优先级等功能时。Bao的实现确实遵循这条路径，因为许多RTOS使用中断优先级，有时甚至作为任务调度机制[33,40]。这个问题在最新版本的规范GICv4中得到了解决，它绕过了虚拟机管理程序来传递客户机中断[12]。此外，有限的虚拟化支持要求客户机访问中央分配器必须使用“陷阱和仿真”来实现。根据客户机访问分配器的频率和访问模式，这可能会显著降低性能。目前，Bao仅支持GICv2。


## ** 评估**

测试平台：Xilinx ZCU104，采用Zynq-US+ SoC，配备运行频率为1.2 GHz的四核 Cortex-A53、每核32K L1数据和指令缓存以及共享的统一1MB L2/LLC缓存。  

首先评估代码和存储尺寸，然后是启动时间、性能和中断延迟。我们将客户机本地执行/裸机（bare）、托管执行（solo）和竞争下的托管执行（interf）进行比较，以评估运行多个客户机时产生的干扰。然后，启用缓存分区重复两个托管场景（solo-col和interf-col）。  

本文在一个内核中执行目标测试VM，然后执行两个额外的裸机应用程序进行干扰，每个应用程序都在一个单独的VM中运行，它们连续读写一个512 KiB数组，步长等于缓存行大小（64字节）。启用着色时，本文将一半LLC（512 KiB）分配给运行基准测试的 VM，将四分之一（256 KiB）分配给每个干扰裸机应用程序。管理程序代码和基准应用程序均使用Arm GNU工具链8.2.1版和-O2优化选项进行编译。

**代码和存储尺寸**

在本节中，我们评估源代码行（SLoC）数量，以及通过最终二进制文件的大小和运行时的使用情况来评估内存占用。  

代码分为四个主要部分：arch和platform目录包含特定于目标的功能，而core和lib目录分别具有主要的管理程序逻辑和实用工具（例如，字符串操作和格式化打印代码）。每个目录的总SLoC和最终二进制大小如表1所示。对于目标平台，总共包含5.6 KSLoC，代码量反映了系统整体的低复杂度。  

大多数代码是用C编写的，低级初始化和上下文保存/恢复（异常进入和退出）等功能必须通过汇编语言实现。还可以看到，特定于体系结构的代码占总SLoC的大部分，这其中最大的部分是GIC虚拟化支持，占Arm-v8代码总量的近1/3。在核心功能中，包括物理页面分配和页表管理的代码占用了540 SLoC。静态分配的内存的大小约为59 KiB。请注意，较大的.bss段尺寸主要是由于根页表的静态分配，最终要加载的二进制文件的总大小约为43 KiB。

![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20250419125040.png)


**引导开销**

在本节中，本文评估Bao的启动时间开销（而不是系统的整体启动时间）。因此，在任何系统或虚拟机的引导阶段都没有进行任何优化。在测试平台上，完整的引导流程包括几个特定于平台的引导阶段：（i）启动ROM执行低级初始化并将第一阶段引导加载程序（FSBL）加载到片上存储器，然后(ii)加载Arm可信平台（ATF）、Bao和客户机镜像到主存储器，接下来，(iii) FSBL跳转到ATF，最后(iv)将控制交给管理程序。  

本文使用在ATF的早期阶段启动的Arm架构中的独立计时器进行测量。因此，这些只是平台总启动时间的近似值，因为它们没有考虑之前的启动阶段。本文考虑两种情况：  

1）运行FreeRTOS的小型VM（117 KiB镜像大小和32 MiB内存）；

2）运行Linux的大型VM（39 MiB镜像大小和512 MiB内存）。

对于每个VM，本文考虑原生执行（bare）场景，以及禁用和启用着色的托管执行（solo和solo-col）场景。本文测量（i）管理程序初始化时间：从管理程序执行第一条指令到它将控制交给VM的时间，以及（ii）总启动时间：从管理程序执行第一条指令到客户机内部第一个应用程序开始的时间。我们在这里强调，Bao不会像其他嵌入式虚拟机管理程序那样执行客户机镜像加载这一事实；这取决于引导加载程序。因此，镜像加载开销仅反映在总时间中。

![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20250419125153.png)
表3显示了每种情况下100个样本的平均结果。在小型VM情况下，管理程序初始化开销最小（solo和solo-col场景分别为6.5和9.2毫秒）。与裸机方案bare相比，总启动时间分别增加了大约13（0.5%）和16（0.6%）毫秒。在运行Linux客户机的大型VM的情况下，solo和solo-col情况下Bao分别需要大约9.6毫秒和156.2毫秒来初始化自身以及VM。与原生执行相比，在禁用和启用着色的情况下，总启动时间分别增加了大约83（0.7 %）毫秒和184（2.4 %）毫秒。要强调的第一点是，启用着色后管理程序初始化时间的大幅增加。这主要是因为Bao需要对引导加载程序的扁平镜像进行着色，在此过程中将镜像的几段复制到颜色兼容的页面中。在大型客户机镜像的情况下，这一情况会更加严重。其次，总启动时间的增加总是大于管理程序初始化时间。我们认为这是客户机初始化期间虚拟化开销的结果（例如2阶段转换和GIC分配器的“陷阱和仿真”）。

## **性能开销和干扰**

为了评估虚拟化性能开销和VM间干扰，本文采用了广泛使用的MiBench Embedded Benchmark Suite[14]。MiBench是一组35个基准测试，分为六个子集，每个子集都针对嵌入式市场的特定领域：汽车和工业控制、消费设备、办公自动化、网络、安全和电信。对于每个基准测试，MiBench提供两个输入数据集（小型和大型）。本文将评估重点放在汽车子集上，因为这是Bao所针对的主要应用领域之一。它包括三个内存密集型基准测试，因此更容易受到缓存和内存争用[7]（qsort、susan corners 和 susan edges）的干扰。

![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20250419125230.png)

最后，本文可以看到通过着色进行缓存分区可以显著减少干扰。表4显示，着色可以将L2未命中率完全降低到单独着色场景的水平。然而，回顾图2，可以看到这种削减并没有反映在观察到的性能下降中，interf-col中的性能下降仍然高于solo-col场景。内存停顿率的差异说明LLC下游还有没有解决的争用问题，例如回写缓冲区、缺失状态处理寄存器（MSHR）、互连和内存控制器。正如预期的那样，basicmath和bitcount受着色和干扰的影响要小得多，因为它们占用的内存要少得多。  

图2中的另一个明显趋势是，性能下降在基准的小数据集中总是更加明显。在比较小型和大型输入数据集时，我们看到，尽管表4中L2缓存未命中率的增加相似，小型版本遭遇了更大的性能下降。我们认为这可能是因为小输入数据集基准的总执行时间较短，缓存未命中的惩罚对它们会产生更大的影响。这个想法得到了表中观察到的内存停顿率的支持，这在小输入数据集的情况下会导致更高的百分比增加。

![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20250419125352.png)

## **未来发展**

Bao的发展还处于初期阶段。在撰写本文时，我们正在扩展对Arm架构的支持，包括 SMMU（Arm的IOMMU）和最新的GIC版本（v3和v4）。我们还将系统移植到一系列不同的平台，包括英伟达的Jetson TX2和恩智浦的i.MX 8（编者注：这部分工作已经完成，Bao还在embedded world 2025演示了对英飞凌TC4的支持）。此外，鉴于代码库较小，我们计划进行整体重构以遵守MISRA C编码规范。  

Bao从一开始就实现了缓存着色，作为微架构分区和隔离的第一线。我们的目标是实现其他最先进的分区机制（例如内存节流），并对虚拟机管理程序镜像本身进行着色，因为本文已经验证虚拟机之间或虚拟机与虚拟机管理程序之间仍然存在争用问题。但是，我们认为这些问题应该得到专用硬件机制的支持，以不增加代码复杂性和尺寸，以及最小化开销。事实上，Arm已经在Arm v8.4上提出了内存系统资源分区和监控（MPAM）[25]扩展。MPAM为共享缓存、互连和内存带宽分区提供硬件支持。不幸的是，迄今为止还没有具有这些扩展功能的硬件可用。本文计划使用Arm基础平台（AFP）模型实现对MPAM 的支持，以便我们在真实硬件面世时能够立即对其进行测试。  

最后，由于Bao也是一个面向安全的虚拟机管理程序，因此可信执行环境 (TEE) 支持也在开发中。通常，Arm TEE以TrustZone技术为基础，这是一组安全的硬件扩展，可将平台分成一个安全和正常的世界[37]。TEE内核和应用程序在安全端运行，而其他一切（包括管理程序）在正常世界中执行。目前，TrustZone不支持多个隔离的TEE。学术界已经提出了几种安全的世界虚拟化方法[18,10,24]。最近，Arm在Arm v8.4上增加了安全世界虚拟机管理程序支持。然而，基于TrustZone的TEE的双世界方法已被证明存在缺陷[9]。此外，我们认为运行额外的安全管理程序会不必要地增加复杂性，并且安全世界应该只用于封装绝对安全的原语（例如安全启动、证明、身份验证、密钥管理）。Bao的方法将考虑到这一点，使用现有的虚拟化机制，无需额外的调度逻辑，允许在正常世界中的单个硬件分区内有多个VM。TEE将部署在辅助VM上，并且仅根据主机/客户机的请求执行。这种方法的另一个优点是它可以跨架构移植和扩展，而不是特定于Arm。