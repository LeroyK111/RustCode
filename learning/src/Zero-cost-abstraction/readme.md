# 零成本抽象

零成本抽象是编程中的一种抽象，一旦编译，与手动编写代码相比，在性能方面不会产生额外的成本。从本质上讲，抽象并不会增加运行时开销——它就像你自己编写底层操作一样高效。Rust的所有权系统、迭代器和Trait经常被称赞为零成本。它们允许开发人员编写优雅、安全和高级的代码，同时仍然保持像C这样的底层语言的速度和效率。

## 什么时候抽象不是零成本

虽然许多Rust抽象是零成本的，但有些抽象会引入性能开销，这取决于它们的使用方式。让我们看一下Rust中抽象可能不是零成本的一些常见情况。

### 1. 动态分派与dyn Trait

Rust中的动态分派允许你编写灵活的多态代码，但这是有代价的。当使用dyn Trait时，Rust必须通过虚函数表在运行时查找要调用的实际方法，与静态分派(方法调用在编译时解析)相比，这增加了一些开销。

```rust
fn process_shape(shape: &dyn Shape) {
    shape.draw();
}
```
在上面的例子中，每次调用shape.draw()都会产生运行时开销，以便通过虚函数表查找实际的方法实现。代替方案：如果性能很关键，而你不需要多态性，考虑使用泛型静态分派：

```rust
fn process_shape<T: Shape>(shape: &T) {
    shape.draw();
}
```
在这里，编译器在编译时就知道要调用哪个方法，从而消除了运行时查找。


### 2. 抽象中的分配

Rust的集合(如Vec、HashMap和String)是强大的抽象，但它们依赖于动态内存分配。虽然这些方法对于许多用例都是有效的，但是如果不小心管理，堆分配的成本可能会累积。例如，当将元素推入Vec时，如果内部容量不够大，Rust将需要重新分配内存来扩展存储。这种重新分配在时间和内存使用方面都是代价高昂的：

```rust
let mut vec = Vec::new();
for i in 0..100 {
    vec.push(i); // 可能触发重新分配
}
```
提示：如果提前知道集合的大致大小，请使用Vec::with_capacity()预分配内存，以避免频繁的重新分配。

```rust
let mut vec = Vec::with_capacity(100);
for i in 0..100 {
    vec.push(i); // 没有重新分配，因为容量已知}
```

### 3. 使用async/await进行异步编程

Rust的async/await系统提供了一种强大且符合人体工程学的方式来处理异步编程。然而，为异步函数生成的状态机可能会带来开销。当使用async fn时，Rust会创建一个表示该函数的状态机，它在内存或CPU使用方面是有开销的。

```rust
async fn fetch_data() {
    let data = get_data().await;
}
```
每个await点都会增加开销，因为Rust需要存储函数的状态并在稍后恢复它。虽然async/await比许多其他模型(如线程)更有效，但它不是零成本的。关键是要理解，虽然异步抽象可以最大限度地减少阻塞，但由于状态机管理，它们仍然会产生性能损失。


### 4. 闭包和Fn Trait

Rust的闭包是简洁的函数式编程的好工具。然而，它们可能会引入开销，这取决于它们的使用方式。当使用闭包时，它会捕获其环境，根据捕获机制的不同，这可能会导致内存分配或额外的间接性性能开销。例如，通过引用捕获变量的闭包可能会在运行时导致额外的解引用：

```rust
let x = 10;
let closure = || println!("{}", x); // Captures `x` by reference
closure();
```
提示：当性能很重要时，请考虑闭包是按值还是按引用捕获变量，并选择最适合需求的方法。你还可以显式地使用move闭包来转移所有权，在某些情况下减少间接性。



## 如何识别非零成本抽象

并非所有的性能缺陷都是显而易见的，尤其是在Rust这样的语言中，安全性和人体工程学与性能同等重要。然而，你可以使用一些工具和策略来识别抽象何时不是零成本的：分析工具：像perf和valgrind这样的工具可以帮助分析你的Rust应用程序，并确定在哪里引入了开销。基准测试：使用Rust内置的基准测试工具(通过cargo bench)来衡量代码中不同抽象的性能。检查汇编：对于深度优化，可以使用cargo rustc --release -- --emit=asm来检查生成的汇编代码，这有助于识别抽象在哪里导致了额外的指令。