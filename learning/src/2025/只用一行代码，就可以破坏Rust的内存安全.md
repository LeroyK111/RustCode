Rust应该是内存安全的，但是如果我告诉你，某个计算机奇才只是想出了下面一行代码，就破坏了rust编译器，破坏了安全承诺。
![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20250124223137.png)

这个缺陷非常容易理解，我们将这段代码解构一下，先把向量提取到一个变量中，然后定义一个make_static函数。
![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20250124223301.png)


现在，我们将简单地接受一个引用作为输入并返回相同的引用，在这种情况下，我们将引用传递给返回的向量，然后打印出来。

现在，如果我们在调用println!之前显式地删除vec，会发生什么呢？Rust编译器将正确抛出一个错误：一旦底层值被删除，我们就不能使用引用，因为引用现在指向无效内存。

但是如果我们能够欺骗编译器呢，首先，我们需要认识到make_static函数签名实际上是下面代码的语法糖：

![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20250124223320.png)

传递给函数的引用和从函数返回的引用都被赋予了泛型生命周期，这基本上意味着两个引用具有相同的生命周期。

在这个例子中，两个引用在相同的时间内有效，我们传入一个对vec的引用，该引用在vec被删除之前一直有效，所以这意味着从make_static函数返回的引用在vec被删除之前也是有效的，这就是为什么当我们试图在下一行打印出evil时编译器会抛出错误。

但是，如果我们修改make_static函数，使其返回具有静态生命周期的引用，静态生命周期意味着引用在程序的整个运行期间内都有效：
![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20250124223337.png)

现在你可以看到为什么我们称这个函数为静态函数了，如果这个有效，我们就可以编译有严重内存安全漏洞的代码了。

这是因为Rust编译器将允许我们打印evil，evil将具有一个静态的生命周期，并且在程序的整个运行时间内被认为是有效的，即使在这个场景中底层的值已经被删除。

打印出evil会导致未定义的行为，这是Rust应该防止的一种漏洞，幸运的是，在现实中，Rust编译器足够聪明，可以拒绝这段代码，因为它会抛出另一个错误：

![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20250124223356.png)
这一次，我们不能返回泛型生命周期为'a的引用，因为该生命周期可能比静态生命周期短。

但这就是缺陷所在，一个Rust奇才能够通过添加一个辅助函数和改变make_static函数的主体来解决这个编译时错误：
![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20250124223413.png)
这段代码使用了一些非常复杂的Rust特性，GitHub提供了所有细微差别的细节，但基本上是通过使用方差和隐含边界的组合来嵌套引用。

这段代码欺骗了Rust编译器，认为应该保证内存安全，让它接受这些内存不安全的代码，并成功地用这些代码进行了编译。
![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20250124223431.png)


现在，我们能够打印出evil，并导致未定义的行为，这会导致数据损坏，安全漏洞和程序崩溃。

这是Rust类型系统中一个相当严重的漏洞，那么为什么这么长时间都没有解决呢？

- 首先，这个bug很难修复，因为它涉及到Rust类型系统的微妙方面。

- 其次，这个bug带来的更多的是理论上的风险，而不是经常在日常Rust代码库中造成漏洞的问题，据说有些开发人员并不太在意。  
    

  

但是，一些开发人员对这个问题仍未解决感到不太高兴，因为这个bug可以被利用。例如，完全用Rust编写的依赖库仍然可能由于这个缺陷潜在地违反内存安全，从而使你的代码产生漏洞，暴露于供应链攻击。