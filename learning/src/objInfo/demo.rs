/*
! 不存在继承概念，只有创建，修改，借用，销毁

面向对象之结构继承
一切先从最简单的开始。面向对象届有句老话：“多用组合，少用继承”，被奉为圭臬，很多对代码的批评就源自于没遵守它。让我们对比一下：

struct A {
    x: int,
}

struct B1 extends A {
    y: int,
}

struct B2 {
    a: A,
    y: int,
}


B1好，还是B2好？其实无法回答的。然而，看下B1、B2这两者的内存布局，会惊讶的发现，它们其实是一样的。

看到这里，我第一次怀疑，这么多年的“继承” vs “组合”的争论，是否有必要，我们怎么会这么傻，为了一个相同的东西，还能喋喋不休了这么多年🐶。

不过，有人可能会问了，这种只是内存布局一样，实际上能一样吗，B1、B2对x的访问是不一样的。

// B1是这样访问x的
int get_x = b1.x;

// 而B2是通过a访问的
int get_x = b2.a.x;

确实不一样，但实际上b2.x可以看成b2.a.x的语法糖。到最终编译到的汇编语言层面，真也的确如此。Rust语言可以轻松使用Deref特质实现该语法糖，连调用A的方法都能一并简化。

impl Deref for B2 {
    type Target = A;

    fn deref(&self) -> &Self::Target {
        &self.a
    }
}

所以，别在讨论，该用组合还是该用继承了！继承本身就是组合，还有啥好讨论的，就算组合多个不同结构，也等同于多继承的概念。

了解到这一点，对底层而言，"is-a"就是"has-a"，高级语言为其发明了“继承”，此时显的多此一举。底层结构上都一样，所以go语言的结构继承，看上去就是组合，rust亦如此。继承就是一种特殊的组合！

但组合可不仅仅是继承，组合变化更多。组合还可以包含一个“指针”型结构，"has-a-ref"，这在链表、树这种自包含结构里尤其关键；组合还能包含一个集合——"has-many"，"has-a"都可以看成是"has many"的特例，比如树包含不止一个枝干。

// 表达能力上，B3更强，B1、B2都可以用B3来表示，B2不过是B3中包含长度为1的向量
struct B3 {
    a: Vec<A>,
    y: int,
}

面向对象的一个尴尬就是，本身继承的底层结构是组合，功能上也不如组合，却把“继承”提高到“三大概念”的核心层次，因小失大，以偏概全。从这点看，"has-a"拥有相同结构，加上"is-a"的语法糖，所以go、rust，概念更少，还能表达出“继承”，亦不失组合的含义，更受欢迎。

但话说回来，面向对象，其实有个关键的语法习惯改进，即以对象为主语的调用方式，类自然语言的“主-谓”或者“主-谓-宾”语句，终于不用主语倒置了，现在大部分语言都是默认如此了，Rust也是如此。这时候再考虑继承，若论直接使用父类的谓词行为，则是“is-a”的继承独有的，“has-a”/“has-a-ref”都要借助语法糖或者重新实现父类接口来表达这种"is-a"父类的行为。“has-many”如果也能表现出"is-a"的特性，那就是经典的组合模式了。不过大多时候是“has-many”表现不出“is-a”的特性，仅仅是一种集合管理。

impl DrawWidget for A {
    fn draw(&self, canvas: &mut Canvas) {
        ...
    }
}

// B1已天然实现了DrawWidget，仍可选覆盖实现
// impl DrawWidget for B1 { ... }

// B2则需要实现“is-a”。在Rust语言里，即便B2实现了Deref，也不代表着
impl DrawWidget for B2 {
    fn draw(&self, canvas: &mut Canvas) {
        self.a.draw(canvas);
        // draw y
    }
}

// B3是“has-many”，但本身也可以看成是一个Widget的话，那就是面向对象中经典的组合模式
impl DrawWidget for B3 {
    fn draw(&self, canvas: &mut Canvas) {
        for child in self.a {
            child.draw(canvas);
        }
        // draw y
    }
}

总结一下，"has"包括

"has-a"

若意义等同于"is-a"，则为继承；包括"has-(a,b)"等同于"is-(a,b)"型，多继承概念

若不等同于"is-a"，则为简单的包含关系，如一个数据包包含包头和包体，一个分数包含分子和分母等

有时候，即可以用继承，也可以用组合，比如代理模式，就有继承代理和组合代理2种，其结构本相同，何须再分出你我，这就是面向对象不必要的高级概念复杂化

"has-a"还可以是"has-a-ref"，C/C++中包含一个其他结构的指针成员，内存结构不同于继承，却也能形如继承，是组合的一种，链表这类自包含结构必备

"has-many"

若还有跟"is-a"一样的特性，就是组合模式

普通的集合管理

回到面向对象语义/语言，要问该选哪一种，就看那种能更精准地表达，猫是动物、鸭子是动物，这种就是继承，猫、鸭子继承了动物，肯定比猫、鸭子包含一个动物结构好。而树包括枝干，就是包含关系好。高级语言，对同一结构不同表达，怎么方便人理解怎么来，如此而已。

在Rust语言中，则没了继承的概念，都是组合。因为Rust的Deref，让Rust保留了继承的部分功能性，并没有关闭面向对象的大门。但需注意，B2并未因Deref自动继承实现A所有的特质。Rust舍弃了高级语言复杂的“继承”概念，把底层是什么样就是什么样的组合原汁原味地展现出来，同时保留下其他变化，既继承的弊端可以被摒弃替换成组合或者特质实现的变化，这种变化也许才是那更常见的大多数情况，废除“继承”可能会是未来语言的标准做法。




*/
