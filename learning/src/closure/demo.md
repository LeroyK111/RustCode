# 闭包


闭包是Rust的一个强大特性，它允许函数捕获上下文变量。


## 捕获上下文变量

闭包是可以捕获其周围环境并使用其作用域之外变量的函数。|…|语法用于定义闭包。将闭包视为一个可以捕捉其周围环境快照的摄像机。它们可以在快照时“记住”变量值，并在稍后调用时使用它们。
```rs
let x = 3;
let closure = |num| num * x;
let result = closure(2);
```
本例中的闭包从环境中捕获变量' x '，并将其乘以输入' num '。


## 闭包的灵活特质

闭包可以通过三种方式捕获变量，具体取决于所需的功能：

1，通过引用捕获：允许你查看和使用变量，但不允许你修改或移动它。

2，通过可变引用捕获：允许使用、修改和重新排列变量但不能删除变量。

3，按值捕获：允许你提取变量并根据需要使用它，包括将其移动到另一个位置。

```rs
let x = 3;
let by_ref = || println!("{}", x); // 通过引用捕获x
let mut y = 5;
let by_mut_ref = || { y += 1; println!("{}", y); }; // 通过可变引用捕获y
let by_value = move || println!("{}", x); // 按值捕获x
```

## 闭包作为输入参数

当一个闭包被用作输入参数时，它的完整类型必须用以下特征之一进行注释：

1，Fn：闭包通过引用使用捕获的值。(&T)

2，FnMut：闭包通过可变引用使用捕获的值。(&mut T)

3，FnOnce：闭包使用捕获的值。(T)
```rs
fn apply<F: Fn(i32) -> i32>(f: F, num: i32) -> i32 {
    f(num)
}

let double = |x| x * 2;
let result = apply(double, 4);
```

## 匿名类型

闭包具有匿名类型，在用作函数参数时必须与泛型一起使用。
```rs
fn call_twice<F>(closure: F, value: i32) -> i32
where
    F: Fn(i32) -> i32,
{
    closure(value) + closure(value)
}

let add_five = |x| x + 5;
let result = call_twice(add_five, 10);
```
使用' where '子句的泛型来基于闭包的行为约束闭包类型，允许我们在不知道其确切类型的情况下与它进行交互。

## 输入函数：将函数作为参数传递

闭包和函数都可以用作参数。在声明以闭包为参数的函数时，任何满足闭包特征边界的函数都可以作为参数传递。
```rs
fn square(x: i32) -> i32 {
    x * x
}

let result = apply(square, 4); // 传递一个函数而不是闭包

```

## 闭包作为返回值

可以将闭包作为输出参数返回，但由于匿名闭包类型在定义上是未知的，因此必须使用impl Trait来这样做。

以下是返回闭包的有效特征：

1，Fn

2，FnMut

3，FnOnce

```rs
fn create_adder(x: i32) -> impl Fn(i32) -> i32 {
    move |y| x + y
}

let add_five = create_adder(5);
let result = add_five(10);
```
本例中的create_adder函数返回一个闭包，将x添加到其输入中。闭包使用' move '关键字按值捕获x，该函数返回一个带有impl Fn(i32) -> i32的闭包。

闭包是Rust中的一个强大且可适应的特性，允许你从环境中捕获和使用变量。

# Rust：临时变量的生命周期

## 临时变量

下面是一个没有上下文的Rust语句，它使用了一个临时字符串变量：
```
f(&String::from('🦀'));
```

这个临时字符串存在多长时间？如果我们设计Rust语言，我们基本上可以从两种选项中选择：

在调用f之前，字符串会被立即删除。


字符串只会在调用f之后被删除。


如果我们使用选项1，上面的语句将总是导致借用检查错误，因为我们不能让f借用已经不存在的东西。

因此，Rust选择了选项2：首先分配String，然后将对它的引用传递给f，只有在f调用返回后才删除临时String。


## 在let语句中

现在有一个稍微难一点的问题：
```
let a = f(&String::from('🦀'));
…
g(&a);
```

再问一次：临时字符串变量的生命周期是多长？

字符串在let语句的末尾被删除，在f返回之后，但在g被调用之前。



在调用g之后，字符串将与a同时被丢弃。



这一次，选项1可能有效，取决于f的签名。如果f被定义为fn f(s: &str) -> usize，那么在let语句之后立即删除String是完全可以的。

然而，如果f被定义为fn f(s: &str) -> &[u8]，那么a将从临时String变量中产生借用，因此如果我们将a保留更长时间，我们将得到一个借用检查错误。

对于选项2，它在两种情况下都可以很好地编译，但是我们可能会保留一个临时变量比必要的存活时间更长，这可能会浪费资源或导致微妙的错误(例如，当MutexGuard比预期的更晚被丢弃时，会出现死锁)。

在选项1和选项2之间，Rust选择了选项1：在let语句末尾删除临时变量。手动将String移动到单独的let语句中以使其保持更长的生命周期。
```
let s = String::from('🦀');
let a = f(&s);
…
```



## 在嵌套调用中

再看一个更复杂的：
```
g(f(&String::from('🦀')));
```

同样，有两种选择：

在调用f之后，但在调用g之前，字符串被删除。



该字符串将在语句结束时删除，因此在调用g之后。



该代码段与前一个代码段几乎相同：将对临时String变量的引用传递给f，并将其返回值传递给g。不过，这一次，使用了单个的嵌套调用表达式语句。

根据f的签名，选项1可能起作用，也可能不起作用，选项2可能使临时变量的生命周期存在的时间比必要的长。

选项1会使像
`String::from('🦀').as_bytes().contains(&0x80)`
这样简单的东西也不会通过编译，因为字符串会被丢弃在as_bytes[f]之后，在contains[g]之前。

因此，Rust选择了选项2：不管f的签名是什么，String都保持存活，直到语句结束，直到调用g之后。


## 在if语句中

现在让我们来看一个简单的if语句：
```
if f(&String::from('🦀')) {
    …
}
```

同样的问题：什么时候删除临时字符串变量？

在if语句的条件求值之后，但在if语句体执行之前(即在{处)。



在if函数体之后(即在}处)。



在这种情况下，没有理由在if语句体期间保持临时变量的存活。该条件的结果是一个布尔值(只有true或false)，根据定义，它不借用任何东西。

所以，Rust选择了选项1。

一个有用的例子是使用Mutex::lock，它返回一个临时的MutexGuard，当它被丢弃时将解锁互斥锁：
```
fn example(m: &Mutex<String>) {
    if m.lock().unwrap().is_empty() {
        println!("the string is empty!");
    }
}
```

这里，m.lock().unwrap()中的临时变量MutexGuard在.is_empty()之后被删除，这样在println语句期间互斥量就不会不必要地保持锁定状态。

## 在if let语句中

但是，if let和match的情况不同，因为我们的表达式不一定求值为布尔值：
```
if let … = f(&String::from('🦀')) {
    …
}
```

还是有两种选择：

在模式匹配之后，在if let的主体之前(即在{处)删除字符串。



在if let语句体之后(即在}处)删除该字符串。



这一次，我们有理由选择第二种而不是第一种。在if let语句或match这种模式匹配语句中，借用某些东西是很常见的。

因此，在这种情况下，Rust选择了选项2。例如，如果我们有一个Mutex<Vec<T'>>类型的vec，下面的代码编译得很好：
```
if let Some(x) = vec.lock().unwrap().first() {
    // 互斥对象仍然被锁在这里
    // 因为我们从Vec中借用了x. (`x` 是 `&T`)
    println!("first item in vec: {x}");
}
```

我们从.lock().unwrap()中获得一个临时变量MutexGuard，并使用.first()方法借用第一个元素。这个借用在if let的整个主体中需要持续锁定，因此MutexGuard只在最后的}处被删除。

然而，在某些情况下，这并不是我们想要的。例如，如果我们不使用first，而是使用pop，它返回一个值而不是引用：
```
if let Some(x) = vec.lock().unwrap().pop() {
    // 互斥对象仍然被锁在这里
    // 这是不必要的，因为我们没有从Vec中借用任何东西。(“x” 是 “T”)
    println!("popped item from the vec: {x}");
}****
```

这可能会导致细微的错误或性能降低。

目前，解决方法是使用单独的let语句，将临时生命周期限制为let语句中：
```
let x = vec.lock().unwrap().pop(); // MutexGuard在此语句之后被删除
if let Some(x) = x {
    …
}
```


